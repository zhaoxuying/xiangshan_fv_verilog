// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module ICacheReplacer(
  input        clock,
  input        reset,
  input        io_touch_0_valid,
  input  [1:0] io_touch_0_bits_vSetIdx,
  input  [1:0] io_touch_0_bits_way,
  input        io_touch_1_valid,
  input  [1:0] io_touch_1_bits_vSetIdx,
  input  [1:0] io_touch_1_bits_way,
  input        io_victim_vSetIdx_valid,
  input  [1:0] io_victim_vSetIdx_bits,
  output [1:0] io_victim_way
);

  reg  [2:0] state_vec_0;
  reg  [2:0] state_vec_1;
  reg  [2:0] state_vec_1_0;
  reg  [2:0] state_vec_1_1;
  wire [2:0] _GEN = io_victim_vSetIdx_bits[1] ? state_vec_1_1 : state_vec_1_0;
  wire [2:0] _GEN_0 = io_victim_vSetIdx_bits[1] ? state_vec_1 : state_vec_0;
  wire [1:0] io_victim_way_0 =
    io_victim_vSetIdx_bits[0]
      ? {_GEN[2], _GEN[2] ? _GEN[1] : _GEN[0]}
      : {_GEN_0[2], _GEN_0[2] ? _GEN_0[1] : _GEN_0[0]};
  reg  [1:0] victim_vSetIdx_reg;
  reg  [1:0] victim_way_reg;
  reg        touch_ways_0_1_valid_REG;
  reg        touch_ways_1_1_valid_REG;
  wire       touch_sets_0_0 =
    io_touch_0_bits_vSetIdx[0] ? io_touch_1_bits_vSetIdx[1] : io_touch_0_bits_vSetIdx[1];
  wire [1:0] touch_ways_0_0_bits =
    io_touch_0_bits_vSetIdx[0] ? io_touch_1_bits_way : io_touch_0_bits_way;
  wire       touch_ways_0_0_valid =
    io_touch_0_bits_vSetIdx[0] ? io_touch_1_valid : io_touch_0_valid;
  wire       touch_sets_1_0 =
    io_touch_1_bits_vSetIdx[0] ? io_touch_1_bits_vSetIdx[1] : io_touch_0_bits_vSetIdx[1];
  wire [1:0] touch_ways_1_0_bits =
    io_touch_1_bits_vSetIdx[0] ? io_touch_1_bits_way : io_touch_0_bits_way;
  wire       touch_ways_1_0_valid =
    io_touch_1_bits_vSetIdx[0] ? io_touch_1_valid : io_touch_0_valid;
  wire       touch_ways_0_1_valid = touch_ways_0_1_valid_REG & ~(victim_vSetIdx_reg[0]);
  wire       touch_ways_1_1_valid = touch_ways_1_1_valid_REG & victim_vSetIdx_reg[0];
  wire       set_touch_ways_0_valid = touch_ways_0_0_valid & ~touch_sets_0_0;
  wire       set_touch_ways_1_valid = touch_ways_0_1_valid & ~(victim_vSetIdx_reg[1]);
  wire       set_touch_ways_0_1_valid = touch_ways_0_0_valid & touch_sets_0_0;
  wire       set_touch_ways_1_1_valid = touch_ways_0_1_valid & victim_vSetIdx_reg[1];
  wire       set_touch_ways_0_2_valid = touch_ways_1_0_valid & ~touch_sets_1_0;
  wire       set_touch_ways_1_2_valid = touch_ways_1_1_valid & ~(victim_vSetIdx_reg[1]);
  wire       set_touch_ways_0_3_valid = touch_ways_1_0_valid & touch_sets_1_0;
  wire       set_touch_ways_1_3_valid = touch_ways_1_1_valid & victim_vSetIdx_reg[1];
  wire       _state_vec_0_T_3 =
    touch_ways_0_0_bits[1] ? ~(touch_ways_0_0_bits[0]) : state_vec_0[1];
  wire       _state_vec_0_T_7 =
    touch_ways_0_0_bits[1] ? state_vec_0[0] : ~(touch_ways_0_0_bits[0]);
  wire [1:0] _state_vec_0_T_9 =
    set_touch_ways_0_valid ? {_state_vec_0_T_3, _state_vec_0_T_7} : state_vec_0[1:0];
  wire       _state_vec_1_T_3 =
    touch_ways_0_0_bits[1] ? ~(touch_ways_0_0_bits[0]) : state_vec_1[1];
  wire       _state_vec_1_T_7 =
    touch_ways_0_0_bits[1] ? state_vec_1[0] : ~(touch_ways_0_0_bits[0]);
  wire [1:0] _state_vec_1_T_9 =
    set_touch_ways_0_1_valid ? {_state_vec_1_T_3, _state_vec_1_T_7} : state_vec_1[1:0];
  wire       _state_vec_0_T_23 =
    touch_ways_1_0_bits[1] ? ~(touch_ways_1_0_bits[0]) : state_vec_1_0[1];
  wire       _state_vec_0_T_27 =
    touch_ways_1_0_bits[1] ? state_vec_1_0[0] : ~(touch_ways_1_0_bits[0]);
  wire [1:0] _state_vec_0_T_29 =
    set_touch_ways_0_2_valid
      ? {_state_vec_0_T_23, _state_vec_0_T_27}
      : state_vec_1_0[1:0];
  wire       _state_vec_1_T_23 =
    touch_ways_1_0_bits[1] ? ~(touch_ways_1_0_bits[0]) : state_vec_1_1[1];
  wire       _state_vec_1_T_27 =
    touch_ways_1_0_bits[1] ? state_vec_1_1[0] : ~(touch_ways_1_0_bits[0]);
  wire [1:0] _state_vec_1_T_29 =
    set_touch_ways_0_3_valid
      ? {_state_vec_1_T_23, _state_vec_1_T_27}
      : state_vec_1_1[1:0];
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      state_vec_0 <= 3'h0;
      state_vec_1 <= 3'h0;
      state_vec_1_0 <= 3'h0;
      state_vec_1_1 <= 3'h0;
      victim_vSetIdx_reg <= 2'h0;
      victim_way_reg <= 2'h0;
    end
    else begin
      if (set_touch_ways_0_valid | set_touch_ways_1_valid) begin
        if (set_touch_ways_1_valid)
          state_vec_0 <=
            {~(victim_way_reg[1]),
             victim_way_reg[1] ? ~(victim_way_reg[0]) : _state_vec_0_T_9[1],
             victim_way_reg[1] ? _state_vec_0_T_9[0] : ~(victim_way_reg[0])};
        else if (set_touch_ways_0_valid)
          state_vec_0 <= {~(touch_ways_0_0_bits[1]), _state_vec_0_T_3, _state_vec_0_T_7};
      end
      if (set_touch_ways_0_1_valid | set_touch_ways_1_1_valid) begin
        if (set_touch_ways_1_1_valid)
          state_vec_1 <=
            {~(victim_way_reg[1]),
             victim_way_reg[1] ? ~(victim_way_reg[0]) : _state_vec_1_T_9[1],
             victim_way_reg[1] ? _state_vec_1_T_9[0] : ~(victim_way_reg[0])};
        else if (set_touch_ways_0_1_valid)
          state_vec_1 <= {~(touch_ways_0_0_bits[1]), _state_vec_1_T_3, _state_vec_1_T_7};
      end
      if (set_touch_ways_0_2_valid | set_touch_ways_1_2_valid) begin
        if (set_touch_ways_1_2_valid)
          state_vec_1_0 <=
            {~(victim_way_reg[1]),
             victim_way_reg[1] ? ~(victim_way_reg[0]) : _state_vec_0_T_29[1],
             victim_way_reg[1] ? _state_vec_0_T_29[0] : ~(victim_way_reg[0])};
        else if (set_touch_ways_0_2_valid)
          state_vec_1_0 <=
            {~(touch_ways_1_0_bits[1]), _state_vec_0_T_23, _state_vec_0_T_27};
      end
      if (set_touch_ways_0_3_valid | set_touch_ways_1_3_valid) begin
        if (set_touch_ways_1_3_valid)
          state_vec_1_1 <=
            {~(victim_way_reg[1]),
             victim_way_reg[1] ? ~(victim_way_reg[0]) : _state_vec_1_T_29[1],
             victim_way_reg[1] ? _state_vec_1_T_29[0] : ~(victim_way_reg[0])};
        else if (set_touch_ways_0_3_valid)
          state_vec_1_1 <=
            {~(touch_ways_1_0_bits[1]), _state_vec_1_T_23, _state_vec_1_T_27};
      end
      if (io_victim_vSetIdx_valid) begin
        victim_vSetIdx_reg <= io_victim_vSetIdx_bits;
        victim_way_reg <= io_victim_way_0;
      end
    end
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    touch_ways_0_1_valid_REG <= io_victim_vSetIdx_valid;
    touch_ways_1_1_valid_REG <= io_victim_vSetIdx_valid;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        state_vec_0 = _RANDOM[/*Zero width*/ 1'b0][5:3];
        state_vec_1 = _RANDOM[/*Zero width*/ 1'b0][8:6];
        state_vec_1_0 = _RANDOM[/*Zero width*/ 1'b0][14:12];
        state_vec_1_1 = _RANDOM[/*Zero width*/ 1'b0][17:15];
        victim_vSetIdx_reg = _RANDOM[/*Zero width*/ 1'b0][19:18];
        victim_way_reg = _RANDOM[/*Zero width*/ 1'b0][21:20];
        touch_ways_0_1_valid_REG = _RANDOM[/*Zero width*/ 1'b0][22];
        touch_ways_1_1_valid_REG = _RANDOM[/*Zero width*/ 1'b0][23];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        state_vec_0 = 3'h0;
        state_vec_1 = 3'h0;
        state_vec_1_0 = 3'h0;
        state_vec_1_1 = 3'h0;
        victim_vSetIdx_reg = 2'h0;
        victim_way_reg = 2'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_victim_way = io_victim_way_0;
endmodule

